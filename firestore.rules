/**
 * Core Philosophy: This ruleset enforces a strict user-ownership model for all private data,
 * ensuring users can only access information they have created. It structurally separates
 * private user data (like health metrics and recommendations) from public community data
 * (like forum posts and tags) to enable secure and performant queries.
 *
 * Data Structure: Private, user-specific data (CropRecommendation, PestDiseaseDetection,
 * CropHealthMetric) is nested under the `/users/{userId}` path, directly linking the data's
 * location to its owner. Public or global data (ForumPost, WeatherData, Tag, ExpertProfile, CropListing)
 * is stored in top-level collections for easy access by all users.
 *
 * Key Security Decisions:
 * - User Isolation: A user can only read or write their own documents within the `/users/{userId}`
 *   data tree. Listing all users via the root `/users` collection is explicitly forbidden to
 *   prevent user enumeration.
 * - Public Read, Owner Write: Top-level collections like `/forumPosts` and `/cropListings` are readable
 *   by any signed-in user but can only be created, updated, or deleted by the original author,
 *   identified by a `userId` field on the document.
 * - Read-Only Global Data: Collections like `/weatherData`, `/tags`, and `/expertProfiles` are
 *   treated as globally readable but are not writable by clients. This assumes they are populated
 *   by a trusted backend process, which is a secure default for reference data.
 * - Relational Integrity: On creation, rules validate that the owner ID within a document
 *   matches the owner specified in the path or the creator's auth token. This link is then
 *   enforced as immutable on updates.
 *
 * Denormalization for Authorization: To ensure fast and secure access control, authorization
 * fields are denormalized. For example, a `ForumPost` document contains a `userId` field.
 * This avoids costly and slow `get()` calls in rules, making authorization decisions atomic
 * and efficient.
 *
 * Structural Segregation: Private user data (e.g., `/users/{userId}/cropHealthMetrics`) is
 * stored in a completely separate path from public data (e.g., `/forumPosts`). This is more
 * secure and performant for list operations than using a single collection with a boolean flag.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // Helper functions for readable and maintainable rules.
    function isSignedIn() {
      return request.auth != null;
    }

    // Checks if the requesting user is the owner of a document.
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    // Checks if a document exists and the requesting user is the owner.
    // CRITICAL for safe update and delete operations.
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    /**
     * @description Manages user profile data.
     * @path /users/{userId}
     * @allow (create) An authenticated user can create their own profile document.
     * @deny (get) A user cannot read another user's profile.
     * @principle Restricts access to a user's own data tree and allows self-creation of a profile.
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isOwner(userId) && request.resource.data.id == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.id == resource.data.id;
      allow delete: if false; // User profiles should not be deletable by clients.

      /**
       * @description User-owned crop recommendations. Only accessible by the owner.
       * @path /users/{userId}/cropRecommendations/{cropRecommendationId}
       * @allow (create) The owner can create a new crop recommendation in their own space.
       * @deny (list) A user cannot list another user's crop recommendations.
       * @principle Enforces strict ownership for all reads and writes in a user's private subcollection.
       */
      match /cropRecommendations/{cropRecommendationId} {
        allow get: if isOwner(userId);
        allow list: if isOwner(userId);
        allow create: if isOwner(userId) && request.resource.data.userId == userId;
        allow update: if isExistingOwner(userId) && request.resource.data.userId == resource.data.userId;
        allow delete: if isExistingOwner(userId);
      }

      /**
       * @description User-owned pest and disease detection results. Only accessible by the owner.
       * @path /users/{userId}/pestDiseaseDetections/{pestDiseaseDetectionId}
       * @allow (get) The owner can read one of their pest detection results.
       * @deny (create) A user cannot create a pest detection result for another user.
       * @principle Enforces strict ownership for all reads and writes in a user's private subcollection.
       */
      match /pestDiseaseDetections/{pestDiseaseDetectionId} {
        allow get: if isOwner(userId);
        allow list: if isOwner(userId);
        allow create: if isOwner(userId) && request.resource.data.userId == userId;
        allow update: if isExistingOwner(userId) && request.resource.data.userId == resource.data.userId;
        allow delete: if isExistingOwner(userId);
      }

      /**
       * @description User-owned crop health metrics. Only accessible by the owner.
       * @path /users/{userId}/cropHealthMetrics/{cropHealthMetricId}
       * @allow (list) The owner can list all of their own crop health metrics.
       * @deny (update) A user cannot update another user's metrics.
       * @principle Enforces strict ownership for all reads and writes in a user's private subcollection.
       */
      match /cropHealthMetrics/{cropHealthMetricId} {
        allow get: if isOwner(userId);
        allow list: if isOwner(userId);
        allow create: if isOwner(userId) && request.resource.data.userId == userId;
        allow update: if isExistingOwner(userId) && request.resource.data.userId == resource.data.userId;
        allow delete: if isExistingOwner(userId);
      }
    }

    /**
     * @description Global weather data, readable by all users but not writable by them.
     * @path /weatherData/{weatherDataId}
     * @allow (get, list) Any user, signed in or not, can read weather data.
     * @deny (create, update, delete) No client can modify the weather data collection.
     * @principle Secures global reference data as read-only for clients.
     */
    match /weatherData/{weatherDataId} {
      allow get: if true;
      allow list: if true;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Community forum posts. Readable by all, writable only by the author.
     * @path /forumPosts/{forumPostId}
     * @allow (create) An authenticated user can create a new post, setting themselves as the author.
     * @deny (update) A user cannot update a post written by someone else.
     * @principle Enforces document ownership for writes while allowing public reads.
     */
    match /forumPosts/{forumPostId} {
      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
      allow update: if isExistingOwner(resource.data.userId) && request.resource.data.userId == resource.data.userId;
      allow delete: if isExistingOwner(resource.data.userId);
    }
    
    /**
     * @description Digital marketplace crop listings. Readable by all, writable only by the author.
     * @path /cropListings/{cropListingId}
     * @allow (create) An authenticated user can create a new listing, setting themselves as the author.
     * @deny (update) A user cannot update a listing by someone else.
     * @principle Enforces document ownership for writes while allowing public reads.
     */
    match /cropListings/{cropListingId} {
      allow get: if isSignedIn();
      allow list: if isSignedIn();
      allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
      allow update: if isExistingOwner(resource.data.userId) && request.resource.data.userId == resource.data.userId;
      allow delete: if isExistingOwner(resource.data.userId);
    }


    /**
     * @description Tags for categorizing forum posts. Readable by all.
     * @path /tags/{tagId}
     * @allow (get, list) Any user, signed in or not, can read tags.
     * @deny (create, update, delete) No client can modify the tags collection.
     * @principle Secures global reference data as read-only for clients.
     */
    match /tags/{tagId} {
      allow get: if true;
      allow list: if true;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Publicly viewable profiles for agricultural experts.
     * @path /expertProfiles/{expertProfileId}
     * @allow (get, list) Any user, signed in or not, can read expert profiles.
     * @deny (create, update, delete) No client can modify the expert profiles collection.
     * @principle Secures global reference data as read-only for clients.
     */
    match /expertProfiles/{expertProfileId} {
      allow get: if true;
      allow list: if true;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }
  }
}
